#ifndef STD_EXPERIMENTAL_STACK_VECTOR
#define STD_EXPERIMENTAL_STACK_VECTOR
/// \file
///
/// Dynamically-resizable vector with stack storage.
///
/// Copyright Gonzalo Brito Gadeschi 2015
///
/// This file is released under the Boost Software License:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//
// Some of the code has been adapted from libc++:
//
// and is annotated with "adapted from libc++" below, and is thus under the
// following license:
//
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
#include <cassert>
#include <cstddef>     // for size_t
#include <functional>  // for less and equal_to
#include <iterator>    // for reverse_iterator
#include <stdexcept>   // for length_error
#include <type_traits>

namespace std {
namespace experimental {

#ifndef stack_vector_DOXYGEN_INVOKED

namespace stack_vector_detail {

using std::is_base_of;
using std::input_iterator_tag;

template <typename T> using uncvref_t = remove_reference_t<remove_cv_t<T>>;
template <typename T> using unref_t   = remove_reference_t<T>;

template <typename...> using void_t = void;

template <typename T>
using iterator_category_t =
 typename iterator_traits<remove_reference_t<T>>::iterator_category;

template <typename T, typename U = void> struct InputIterator : false_type {};

template <typename T>
struct InputIterator<T, void_t<iterator_category_t<T>>>
 : is_base_of<input_iterator_tag, iterator_category_t<T>> {};

static_assert(InputIterator<const int*>{}, "");

template <typename T, typename U = void> struct ForwardIterator : false_type {};

template <typename T>
struct ForwardIterator<T, void_t<iterator_category_t<T>>>
 : is_base_of<forward_iterator_tag, iterator_category_t<T>> {};

template <typename T, typename U = void> struct OutputIterator : false_type {};

template <typename T>
struct OutputIterator<T, void_t<iterator_category_t<T>>>
 : integral_constant<bool,
                     (is_base_of<forward_iterator_tag, iterator_category_t<T>>{}
                      and !is_const<T>{})
                      or (is_base_of<output_iterator_tag,
                                     iterator_category_t<T>>{})> {};

static_assert(OutputIterator<int*>{}, "");

template <typename From, typename To>
struct Convertible : is_convertible<unref_t<From>, unref_t<To>> {};

template <typename T>
struct CopyConstructible : is_copy_constructible<uncvref_t<T>> {};

#define REQUIRES_(...) typename = enable_if_t<(__VA_ARGS__)>

#define REQUIRES(...)       \
  template <int dummy = 42, \
            typename  = enable_if_t<(dummy == 43) || (__VA_ARGS__)>>

template <typename InputIt, typename OutputIt,
          REQUIRES_(InputIterator<InputIt>{} and OutputIterator<OutputIt>{})>
constexpr OutputIt move_backward(InputIt b, InputIt e, OutputIt to) {
  while (b != e) { *(--to) = move(*(--e)); }
  return to;
}

template <typename InputIt, typename OutputIt,
          REQUIRES_(InputIterator<InputIt>{} and OutputIterator<OutputIt>{})>
constexpr OutputIt move(InputIt b, InputIt e, OutputIt to) {
  for (; b != e; ++b, (void)++to) { *to = std::move(*b); }
  return to;
}

template <typename OutputIt, typename T, REQUIRES_(OutputIterator<OutputIt>{})>
constexpr OutputIt fill_n(OutputIt b, size_t n, const T& v) {
  for (; n > 0; ++b, --n) { *b = v; }
  return b;
}

template <typename T> constexpr void swap(T&& a, T&& b) {
  uncvref_t<T> tmp = std::move(a);
  a                = std::move(b);
  b                = std::move(tmp);
}

template <class ForwardIt, REQUIRES_(ForwardIterator<ForwardIt>{})>
constexpr void slow_rotate(ForwardIt first, ForwardIt n_first, ForwardIt last) {
  ForwardIt next = n_first;
  while (first != next) {
    swap(*(first++), *(next++));
    if (next == last) {
      next = n_first;
    } else if (first == n_first) {
      n_first = next;
    }
  }
}

template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
constexpr bool equal(_InputIterator1 __first1, _InputIterator1 __last1,
                     _InputIterator2 __first2, _InputIterator2 __last2,
                     _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2;
       ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2)) return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Compare, class _InputIterator1, class _InputIterator2>
constexpr bool lexicographical_compare(_InputIterator1 __first1,
                                       _InputIterator1 __last1,
                                       _InputIterator2 __first2,
                                       _InputIterator2 __last2,
                                       _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2)) return true;
    if (__comp(*__first2, *__first1)) return false;
  }
  return false;
}

/// Storage for a vector of non-trivial elements
template <typename T, size_t Capacity, bool IsTrivial /* = false */>
struct storage {
  static_assert(Capacity != size_t{0}, "");

 private:
  aligned_storage_t<sizeof(T), alignment_of<T>::value> data_[Capacity];
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept {
    return reinterpret_cast<T const*>(data_);
  }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return reinterpret_cast<T*>(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...>
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    new (data() + size()) T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  // cannot be constexpr due to explicit destructor call
  void pop_back() noexcept(is_nothrow_destructible<T>{}) {
    assert(size() > 0);
    auto ptr = data() + size() - 1;
    ptr->~T();
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt first, InputIt last) noexcept {
    for (; first != last; ++first) { first->~T(); }
  }

  /// Destroys all elements of the vector without changing its size (unsafe)
  constexpr void unsafe_destroy_all() noexcept {
    unsafe_destroy(data(), data() + size());
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  storage(initializer_list<T> il) {
    assert(il.size() <= Capacity);
    size_t i = 0;
    for (auto&& v : il) { data_[i] = v; }
    unsafe_set_size(il.size());
  }

  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  ~storage() { unsafe_destroy_all(); }
};

/// Storage for a vector of trivial elements
template <typename T, size_t Capacity>  //
struct storage<T, Capacity, true> {
  static_assert(Capacity != size_t{0}, "");

 private:
  T data_[Capacity]{};
  size_t size_ = 0;

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return data_; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return data_; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...> and (MoveAssignable<T> or
  /// CopyAssignable<T>)
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  constexpr void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    data_[size()] = T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  constexpr void pop_back() noexcept {
    assert(size() > 0);
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt, InputIt) noexcept {}

  /// Destroys all elements of the vector without changing its size (unsafe)
  static constexpr void unsafe_destroy_all() noexcept {}

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;
  storage(initializer_list<T> il) {
    assert(il.size() <= Capacity);
    size_t i = 0;
    for (auto&& v : il) { data_[i] = v; }
    unsafe_set_size(il.size());
  }
  template <
   typename Value, typename... Values,
   typename
   = enable_if_t<!is_same<stack_vector_detail::uncvref_t<Value>, storage>{}>>
  constexpr storage(Value&& v, Values&&... vs)
   : data_{std::forward<Value>(v), std::forward<Values>(vs)...} {
    static_assert(sizeof...(Values) + 1 <= Capacity, "");
    unsafe_set_size(sizeof...(Values) + 1);
  }

  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
};

template <typename T> struct empty_storage {
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return nullptr; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return nullptr; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  static constexpr size_t size() noexcept { return 0; }

  /// Changes the container size (unsafe)
  static constexpr void unsafe_set_size(size_t new_size) noexcept {
    assert(new_size == size_t{0}
           && "trying to set the size of a zero-capacity vector to value != 0");
  }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt first, InputIt last) noexcept {
    assert(first == last);
  }

  /// For trivially destructible types there is nothing to do
  static constexpr void unsafe_destroy_all() noexcept {}

  template <typename... Args>  //
  static constexpr void emplace_back(Args&&...) {
    assert(false);
  }

  static constexpr void pop_back() noexcept { assert(false); }

  explicit empty_storage(size_t n) { assert(n == size_t(0)); }
  empty_storage()                     = default;
  empty_storage(empty_storage const&) = default;
  empty_storage(empty_storage&&)      = default;

  empty_storage& operator=(empty_storage const&) = default;
  empty_storage& operator=(empty_storage&&) = default;

  empty_storage(initializer_list<T> il) { assert(il.size() == 0); }
};

template <typename T>  //
struct storage<T, 0, true> : empty_storage<T> {
  using empty_storage<T>::empty_storage;
  using empty_storage<T>::operator=;
};

template <typename T>  //
struct storage<T, 0, false> : empty_storage<T> {
  using empty_storage<T>::empty_storage;
  using empty_storage<T>::operator=;
};

}  // namespace stack_vector_detail

#endif  // stack_vector_DOXYGEN_INVOKED

/// Dynamically-resizable vector with stack storage
template <typename T, size_t Capacity>  //
struct stack_vector
 : private stack_vector_detail::storage<T, Capacity, is_trivial<T>{}> {
 private:
  using self   = stack_vector<T, Capacity>;
  using base_t = stack_vector_detail::storage<T, Capacity, is_trivial<T>{}>;

 public:
  using base_t::data;
  using base_t::size;
  using base_t::emplace_back;
  using base_t::pop_back;

 private:
  using base_t::unsafe_set_size;
  using base_t::unsafe_destroy;
  using base_t::unsafe_destroy_all;

  template <typename It>
  using InputIterator = stack_vector_detail::InputIterator<It>;

  template <typename From, typename To>
  using Convertible = stack_vector_detail::Convertible<From, To>;

  template <typename U>
  using CopyConstructible = stack_vector_detail::CopyConstructible<U>;

  template <typename U> using uncvref_t = stack_vector_detail::uncvref_t<U>;

  static_assert(is_nothrow_destructible<T>{},
                "stack::vector requires T to be nothrow destructible");

 public:
  using value_type             = T;
  using reference              = value_type&;
  using const_reference        = value_type const&;
  using iterator               = T*;
  using const_iterator         = T const*;
  using size_type              = size_t;
  using difference_type        = ptrdiff_t;
  using pointer                = T*;
  using const_pointer          = T const*;
  using reverse_iterator       = typename std::reverse_iterator<iterator>;
  using const_reverse_iterator = typename std::reverse_iterator<const_iterator>;

  /// \name Iterators
  ///@{

  constexpr iterator begin() noexcept { return data(); }
  constexpr const_iterator begin() const noexcept { return data(); }
  constexpr iterator end() noexcept { return data() + size(); }
  constexpr const_iterator end() const noexcept { return data() + size(); }

  reverse_iterator rbegin() noexcept { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end() - 1);
  }
  reverse_iterator rend() noexcept { return reverse_iterator(data() - 1); }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(data() - 1);
  }

  constexpr const_iterator cbegin() noexcept { return begin(); }
  constexpr const_iterator cbegin() const noexcept { return begin(); }
  constexpr const_iterator cend() noexcept { return end(); }
  constexpr const_iterator cend() const noexcept { return end(); }

  ///@}  // Iterators

  /// \name Construct/copy/move/destroy
  ///@{

  constexpr stack_vector() noexcept : base_t() {}

  /// Can always throw if n > capacity
  constexpr explicit stack_vector(size_type n) { insert(begin(), n); }

  /// can always throw if n > Capacity
  REQUIRES(CopyConstructible<T>{})
  constexpr stack_vector(size_type n, const T& value) {
    insert(begin(), n, value);
  }

  /// TODO:S assert distance for RandomAccessIterator (QoI)
  /// can always throw if distance(first, last) > capacity
  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr stack_vector(InputIt first, InputIt last) {
    insert(begin(), first, last);
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M> const& other) noexcept(
   M <= Capacity and is_nothrow_copy_constructible<T>{}
   and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    insert(begin(), begin(other), end(other));
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector(stack_vector<T, M>&& other) noexcept(
   M <= Capacity and is_nothrow_move_constructible<T>{}
   and is_nothrow_move_assignable<T>{}) {
    move_insert(this->begin(), begin(other), end(other));
  }

  /// same capacity so can only throw if copy constructor or copy assignment can
  /// throw
  constexpr stack_vector(stack_vector const& other) noexcept(
   is_nothrow_copy_assignable<T>{} and is_nothrow_copy_constructible<T>{}) {
    using std::begin;
    using std::end;
    insert(this->begin(), begin(other), end(other));
  }

  /// same capacity so can only throw if move constructor or move assignment
  /// can
  /// throw
  constexpr stack_vector(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    move_insert(this->begin(), begin(other), end(other));
  }
  // can always throw if il.size() > capacity()
  template <typename Value, typename... Values,
            REQUIRES_(Convertible<Value, value_type>{}
                      and sizeof...(Values) > 1)>
  constexpr stack_vector(Value&& v, Values&&... vs)
   : base_t(std::forward<Value>(v), std::forward<Values>(vs)...) {}

  // stack_vector(initializer_list<T> il) : base_t(il) {}

  // using base_t::~base_t;  // inheriting the destructor allows this type to
  // be
  //                         // trivially destructible

  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(other), end(other));
    return *this;
  }
  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr stack_vector& operator=(stack_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    clear();
    move_insert(this->begin(), begin(other), end(other));
    return *this;
  }

  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M> const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    clear();
    insert(begin(), begin(other), end(other));
    return *this;
  }
  /// TODO: conditionally noexcept
  template <std::size_t M, enable_if_t<(Capacity != M)>>
  constexpr stack_vector& operator=(stack_vector<T, M>&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    clear();
    move_insert(this->begin(), begin(other), end(other));
    return *this;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void assign(InputIt first, InputIt last) {
    clear();
    insert(begin(), first, last);
  }

  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(size_type n, const T& u) {
    clear();
    insert(begin(), n, u);
  }
  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(initializer_list<T> const& il) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(il), end(il));
  }
  // cannot move elements out of an initializer_list
  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(initializer_list<T>&& il) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(il), end(il));
  }

///@}  // Construct/copy/move/destroy

/// \name size / capacity
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Number of elements in the vector
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr size_t size() const noexcept;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Number of elements that can be held in the vector storage
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type capacity() noexcept { return Capacity; }

  /// Maximum number of elements the container is able to hold due to system or
  /// library implementation limitations.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type max_size() noexcept { return capacity(); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized
  void reserve(size_type n) /* stack_vector has FIXED CAPACITY */ = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are copy-constructed from \p value.
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     copy-constructions of \p value
  ///   - if \p sz < `size()`: exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  REQUIRES(CopyConstructible<T>{})
  constexpr void resize(size_type sz, T const& value) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_destructible<T>{}) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), value);
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are move-constructed from `T{}` (or copy-constructed if
  /// `T` is not `MoveConstructible`).
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     move or copy-constructions of \p `T{}`
  ///   - if \p sz < `size()`: O(N), exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: MoveInsertable and DefaultInsertable
  constexpr void resize(size_type sz) noexcept(
   is_nothrow_destructible<T>{}
   and ((is_move_constructible<T>{} and is_nothrow_move_constructible<T>{})
        or (is_copy_constructible<T>{}
            and is_nothrow_copy_constructible<T>{}))) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "stack_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size());
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Checks whether the container is empty
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effects: none.
  constexpr bool empty() const noexcept { return size() == size_type(0); }

#ifndef stack_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized:
  void shrink_to_fit() = delete;
#endif  // stack_vector_DOXYGEN_INVOKED

  ///@}  // Size / capacity

  /// \name Element access
  ///@{

  constexpr reference operator[](size_type pos) noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr const_reference operator[](size_type pos) const noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr reference at(size_type pos) {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr const_reference at(size_type pos) const {
    if (pos >= size()) {
      throw out_of_range("cannot access stack_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  REQUIRES(Capacity > 0)
  constexpr reference front() noexcept {
    assert(size() > 0);
    return *begin();
  }
  REQUIRES(Capacity > 0)
  constexpr const_reference front() const noexcept {
    assert(size() > 0);
    return *begin();
  }

  REQUIRES(Capacity > 0)
  constexpr reference back() noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }
  REQUIRES(Capacity > 0)
  constexpr const_reference back() const noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }

///@}  // Element access

#ifdef stack_vector_DOXYGEN_INVOKED
  /// \name Data access
  ///@{

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr const T* data() const noexcept;

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr T* data() noexcept;

///@}  // Data access
#endif  // stack_vector_DOXYGEN_INVOKED

/// \name Modifiers
///@{

#ifdef stack_vector_DOXYGEN_INVOKED
  template <typename... Args> void emplace_back(Args&&... args);
#endif  // stack_vector_DOXYGEN_INVOKED

  /// Push back
  ///
  /// TODO: Cannot be constexpr because of emplace_back usage of placement
  /// TODO: constrain: , CONCEPT_REQUIRES_(Constructible<T, U>{})
  ///   /// TODO: make noexcept if same condition as emplace back
  template <typename U, REQUIRES_(Convertible<U, value_type>{})>
  void push_back(U&& value) {
    emplace_back(forward<U>(value));
  }

#ifdef stack_vector_DOXYGEN_INVOKED
  /// Pop back
  ///
  void pop_back() noexcept(is_nothrow_destructible<T>{});
#endif

  template <class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args) {
    value_type a(forward<Args>(args)...);
    return move_insert(position, &a, &a + 1);
  }
  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, const_reference x) {
    return insert(position, size_type(1), x);
  }
  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, size_type n, const T& x) {
    const auto new_size = size() + n;
    if (new_size > capacity()) throw length_error("");
    auto b = end();
    while (n != 0) {
      push_back(x);
      --n;
    }

    iterator writable_position = begin() + (position - begin());
    stack_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  constexpr iterator insert(const_iterator position, size_type n) {
    const auto new_size = size() + n;
    if (new_size > capacity()) throw length_error("");
    auto b = end();
    while (n != 0) {
      emplace_back();
      --n;
    }

    iterator writable_position = begin() + (position - begin());
    stack_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr iterator insert(const_iterator position, InputIt first,
                            InputIt last) {
    // Decided against optimization for ForwardIterator: we could compute the
    // distance and throw early if it exceeds the capacity, but that makes
    // things faster in the exceptional path, and the extra distance computation
    // makes things slower in the non-exceptional path.
    //
    // TODO: apply this optimization for RandomAccessIterator since then it has
    // ~zero-cost.
    auto b = end();
    //    try {  // if copy_constructor throws you get basic-guarantee?
    for (; first != last; ++first) { push_back(*first); }
    // } catch (...) {
    //   erase(b, end());
    //   throw;
    // }
    // we insert at the end and then just rotate:
    auto writable_position = begin() + (position - begin());
    stack_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr iterator move_insert(const_iterator position, InputIt first,
                                 InputIt last) {
    // Decided against optimization for ForwardIterator: we could compute the
    // distance and throw early if it exceeds the capacity, but that makes
    // things faster in the exceptional path, and the extra distance computation
    // makes things slower in the non-exceptional path.
    //
    // TODO: apply this optimization for RandomAccessIterator since then it has
    // ~zero-cost.
    auto b = end();
    //    try {  // if copy_constructor throws you get basic-guarantee?
    for (; first != last; ++first) { push_back(std::move(*first)); }
    // } catch (...) {
    //   erase(b, end());
    //   throw;
    // }
    // we insert at the end and then just rotate:
    auto writable_position = begin() + (position - begin());
    stack_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, initializer_list<T> il) {
    using std::begin;
    using std::end;
    return insert(position, begin(il), end(il));
  }
  constexpr iterator erase(const_iterator position) {
    return erase(position, position + 1);
  }
  constexpr iterator erase(const_iterator first, const_iterator last) {
    assert(first <= last);
    iterator p = begin() + (first - begin());
    if (first != last) {
      unsafe_destroy(stack_vector_detail::move(p + (last - first), end(), p),
                     end());
      unsafe_set_size(size() - (last - first));
    }

    return p;
  }

  constexpr void clear() noexcept(is_nothrow_destructible<T>{}) {
    unsafe_destroy_all();
    unsafe_set_size(0);
  }

  // TODO: this is rough use std::swap
  constexpr void swap(stack_vector& other) noexcept(
   noexcept(stack_vector_detail::swap(declval<T&>(), declval<T&>()))) {
    using stack_vector_detail::swap;
    stack_vector tmp = std::move(other);
    other            = std::move(*this);
    (*this)          = std::move(tmp);
  }

  /// TODO: swap for different capacities

  ///@}  // Modifiers
};

template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator==(const stack_vector<T, C0>& a,
                          const stack_vector<T, C1>& b) {
  return stack_vector_detail::equal(a.begin(), a.end(), b.begin(), b.end(),
                                    equal_to<>{});
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator!=(const stack_vector<T, C0>& a,
                          const stack_vector<T, C1>& b) {
  return !(a == b);
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator<(const stack_vector<T, C0>& a,
                         const stack_vector<T, C1>& b) {
  return stack_vector_detail::lexicographical_compare(
   a.begin(), a.end(), b.begin(), b.end(), less<>{});
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator<=(const stack_vector<T, C0>& a,
                          const stack_vector<T, C1>& b) {
  return !(a > b);
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator>(const stack_vector<T, C0>& a,
                         const stack_vector<T, C1>& b) {
  return b < a;
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator>=(const stack_vector<T, C0>& a,
                          const stack_vector<T, C1>& b) {
  return !(a < b);
}

}  // namespace experimental
}  // namespace std

#undef REQUIRES_
#undef REQUIRES

#endif  // STD_EXPERIMENTAL_STACK_VECTOR
